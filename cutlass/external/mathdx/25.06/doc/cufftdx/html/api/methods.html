

<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Execution Methods &#8212; cuFFTDx</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/nvidia-sphinx-theme.css?v=df3ac72c" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=f8f0f945"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api/methods';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://docs.nvidia.com/cuda/cufftdx/_static/switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.5.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <link rel="icon" href="../_static/nvidia.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="cuFFTDx Python Bindings" href="../python_bindings.html" />
    <link rel="prev" title="Traits" href="traits.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.5.0" />


  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="cuFFTDx - Home"/>
    <img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark pst-js-only" alt="cuFFTDx - Home"/>
  
  
    <p class="title logo__title">cuFFTDx</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">


<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        



  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/nvidia-logo-horiz-rgb-blk-for-screen.svg" class="logo__image only-light" alt="cuFFTDx - Home"/>
    <img src="../_static/nvidia-logo-horiz-rgb-wht-for-screen.svg" class="logo__image only-dark pst-js-only" alt="cuFFTDx - Home"/>
  
  
    <p class="title logo__title">cuFFTDx</p>
  
</a>


  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">


<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">



<nav class="bd-docs-nav bd-links"
     aria-label="Table of Contents">
  <p class="bd-links__title" role="heading" aria-level="1">Table of Contents</p>
  <div class="bd-toc-item navbar-nav"><ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Documentation home</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../requirements_func.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction1.html">Using cuFFTDx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction2.html">Your Next Custom FFT Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Achieving High Performance</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="operators.html">Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="traits.html">Traits</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Execution Methods</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Python Bindings</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../python_bindings.html">   Python Bindings</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/NVIDIA/CUDALibrarySamples/tree/master/MathDx/cuFFTDx">GitHub Samples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">MathDx</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://developer.nvidia.com/cufftdx-downloads">cuFFTDx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://developer.nvidia.com/cusolverdx-downloads">cuSolverDx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://developer.nvidia.com/cublasdx-downloads">cuBLASDx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://developer.nvidia.com/curanddx-downloads">cuRANDDx</a></li>
<li class="toctree-l1"><a class="reference external" href="https://developer.nvidia.com/nvcompdx-downloads">nvCOMPDx</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>



      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Execution Methods</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="execution-methods">
<span id="execution-methods-label"></span><h1>Execution Methods<a class="headerlink" href="#execution-methods" title="Link to this heading">#</a></h1>
<p>These methods are used to run the FFT operation.</p>
<p>A code example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cufftdx.hpp&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="n">FFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Size</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Type</span><span class="o">&lt;</span><span class="n">fft_type</span><span class="o">::</span><span class="n">c2c</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                    </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Direction</span><span class="o">&lt;</span><span class="n">fft_direction</span><span class="o">::</span><span class="n">forward</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                    </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Precision</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">Block</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>

<span class="k">using</span><span class="w"> </span><span class="n">complex_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>

<span class="n">__global__</span><span class="w"> </span><span class="nf">kernel</span><span class="p">(...</span><span class="w"> </span><span class="cm">/* arguments */</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Shared memory pointer</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">__align__</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">))</span><span class="w"> </span><span class="n">complex_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span>

<span class="w">  </span><span class="c1">// Register data</span>
<span class="w">  </span><span class="n">complex_type</span><span class="w"> </span><span class="n">thread_data</span><span class="p">[</span><span class="n">FFT</span><span class="o">::</span><span class="n">storage_size</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Load data into registers (thread_data)</span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Store results (thread_data) into global memory</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="thread-execute-method">
<span id="thread-execute-method-label"></span><h2>Thread Execute Method<a class="headerlink" href="#thread-execute-method" title="Link to this heading">#</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
</pre></div>
</div>
<p>Runs the FFT operation defined by the FFT descriptor. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">T</span></code> can be any type (such as <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">float2</span></code> or <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">double2</span></code>),
as long as its alignment and element size are the same as those of <a class="reference internal" href="traits.html#valuetype-thread-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<p>This method is available if the descriptor has been constructed using the <a class="reference internal" href="operators.html#thread-operator-label"><span class="std std-ref">Thread Operator</span></a> and
<a class="reference internal" href="traits.html#isfftcompleteexecution-trait-label"><span class="std std-ref">cufftdx::is_complete_fft_execution</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>.</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> array should be in registers. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> must fit <a class="reference internal" href="traits.html#storage-thread-trait-label"><span class="std std-ref">FFT::storage_size</span></a>
elements of type <a class="reference internal" href="traits.html#valuetype-thread-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not guaranteed that executions of exactly the same FFTs on GPUs of different CUDA architectures will produce
bit-identical results.</p>
</div>
</section>
<section id="block-execute-method">
<span id="block-execute-method-label"></span><h2>Block Execute Method<a class="headerlink" href="#block-execute-method" title="Link to this heading">#</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// #1 Execute with input in registers</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">workspace_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">workspace</span><span class="p">)</span>

<span class="c1">// #2: Version of #1 for FFTs which don&#39;t require workspace</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory</span><span class="p">)</span>

<span class="c1">// #3: Execute with input data in shared memory</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory_input</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">workspace_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">workspace</span><span class="p">)</span>

<span class="c1">// #4: Version of #3 for FFTs which don&#39;t require workspace</span>
<span class="kt">void</span><span class="w"> </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">shared_memory_input</span><span class="p">)</span>
</pre></div>
</div>
<p>Runs the FFT operation defined by the FFT descriptor. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">T</span></code> can be any type (such as <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">float2</span></code> or <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">double2</span></code>),
as long as its alignment and element size are the same as those of <a class="reference internal" href="traits.html#valuetype-block-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<p>This method is available if the descriptor has been constructed using the <a class="reference internal" href="operators.html#block-operator-label"><span class="std std-ref">Block Operator</span></a>
and <a class="reference internal" href="traits.html#isfftcompleteexecution-trait-label"><span class="std std-ref">cufftdx::is_complete_fft_execution</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>.</p>
<p>When <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">false</span></code>, overloads #2 and #4 can be used. Otherwise, user has to use
methods #1 or #3 and pass a reference to a workspace.</p>
<p>In all cases a valid pointer to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> must be provided even when no workspace is required and the input is provided in registers. The <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code>
space is used internally for the FFT calculation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The library code assumes that both <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> and <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> are aligned to 128 bits for optimal memory operations.
This can be accomplished by using either <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">__align__</span></code> or <code class="code highlight cpp docutils literal highlight-cpp"><span class="k">alignas</span></code> compiler directives. Proper alignment is demonstrated in example
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">simple_fft_block_shared</span></code>. Please consult CUDA C++ Programming Guide for furher details on memory alignment. Although not required
the user may also consider aligning thread local arrays in the same way, to reduce kernel resource usage.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Examples of how to make sure shared memory pointer is aligned to 128 bits (16 bytes):</span>
<span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="n">float4</span><span class="p">)</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                               </span><span class="c1">// 1</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                                    </span><span class="c1">// 2</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">))</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                       </span><span class="c1">// 3</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">                                                      </span><span class="c1">// 4</span>

<span class="c1">// Warning: std::aligned_storage became deprecated in C++23</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">aligned_storage_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">float4</span><span class="p">),</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span><span class="w">     </span><span class="c1">// 5</span>
</pre></div>
</div>
</div>
</div>
<p>In methods #1 and #2 <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> is in thread local arrays, and <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> is a pointer to a shared memory of size
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span></code> bytes. The operation is in-place meaning the results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> must
fit <a class="reference internal" href="traits.html#storage-block-trait-label"><span class="std std-ref">FFT::storage_size</span></a> elements of type <a class="reference internal" href="traits.html#valuetype-block-trait-label"><span class="std std-ref">FFT::value_type</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Methods #1 and #2 don’t assume that shared memory (<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code>) is safe to modify or access without block synchronization,
and perform required synchronization (<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">__syncthreads</span><span class="p">()</span></code>) before the first use of it. Also, methods #1 and #2 don’t
synchronize any threads within a block after the last operation on shared memory is done. If that shared memory is going to be
reused later a synchronization has to be performed first.</p>
</div>
<p>In methods #3 and #4 the input data is passed in shared memory (<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>). The operation is in-place, meaning
the results are stored back to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>. These methods don’t require an additional <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory</span></code> pointer
to be passed, as <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> will be used for the required communication between threads. Thus, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>
must fit all input and output values, and can’t be smaller than <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span></code> bytes
(i.e. shared memory size in bytes is a maximum of <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span></code>, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&lt;</span><span class="n">FFT_input_size_in_bytes</span><span class="o">&gt;</span></code>, and
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&lt;</span><span class="n">FFT_output_size_in_bytes</span><span class="o">&gt;</span><span class="p">)</span></code> bytes).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Methods #3 and #4, which get input via shared memory, assume that a synchronization was already performed and the data can be safely
accessed. Methods don’t synchronize any threads within a block after the last operation on shared memory is done.
Before reading from or writing to shared memory a synchronization has to be performed first.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not guaranteed that executions of the same FFTs (size, direction, type, precision) but with different</p>
<ul class="simple">
<li><p>number of elements per thread (<a class="reference internal" href="operators.html#ept-operator-label"><span class="std std-ref">ElementsPerThread</span></a>),</p></li>
<li><p>number of FFTs calculated per CUDA block (<a class="reference internal" href="operators.html#fftsperblock-operator-label"><span class="std std-ref">FFTsPerBlock</span></a>), or</p></li>
<li><p>block dimension (<a class="reference internal" href="operators.html#blockdim-operator-label"><span class="std std-ref">BlockDim</span></a>),</p></li>
</ul>
<p>will produce bit-identical results.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is not guaranteed that executions of exactly the same FFTs on GPUs of different CUDA architectures will produce
bit-identical results.</p>
</div>
<section id="shared-memory-usage">
<span id="execution-methods-shared-memory-label"></span><h3>Shared Memory Usage<a class="headerlink" href="#shared-memory-usage" title="Link to this heading">#</a></h3>
<p>It’s important to note that large FFTs may require more than 48 KB of shared memory per CUDA block. Therefore, as described
in <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA Programming Guide</a>
(<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications__technical-specifications-per-compute-capability">#1</a>,
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#shared-memory-7-x">#2</a>,
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#shared-memory-8-x">#3</a>), kernels with such FFTs must use
the dynamic shared memory rather than statically sized shared memory arrays. Additionally, these kernels require
an explicit opt-in using <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaFuncSetAttribute</span><span class="p">()</span></code> to set the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaFuncAttributeMaxDynamicSharedMemorySize</span></code>. See example code
below and the <a class="reference internal" href="../introduction2.html#intro2-extra-shared-memory-label"><span class="std std-ref">introduction example</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cufftdx.hpp&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cufftdx</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">FFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">Size</span><span class="o">&lt;</span><span class="mi">16384</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Precision</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Type</span><span class="o">&lt;</span><span class="n">fft_type</span><span class="o">::</span><span class="n">c2c</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                     </span><span class="o">+</span><span class="w"> </span><span class="n">Direction</span><span class="o">&lt;</span><span class="n">fft_direction</span><span class="o">::</span><span class="n">forward</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">SM</span><span class="o">&lt;</span><span class="mi">800</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Block</span><span class="p">());</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">block_fft_kernel</span><span class="p">(</span><span class="n">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// dynamic shared memory</span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">float4</span><span class="p">))</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">[];</span>

<span class="w">  </span><span class="p">(...)</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(...)</span>

<span class="w">  </span><span class="c1">// Increases the max dynamic shared memory size to match FFT requirements</span>
<span class="w">  </span><span class="n">cudaFuncSetAttribute</span><span class="p">(</span><span class="n">block_fft_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">cudaFuncAttributeMaxDynamicSharedMemorySize</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span><span class="p">)</span>
<span class="w">  </span><span class="c1">// Invokes kernel with FFT::block_dim threads in CUDA block</span>
<span class="w">  </span><span class="n">block_fft_kernel</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">block_dim</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>

<span class="w">  </span><span class="p">(...)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="make-workspace-function">
<span id="make-workspace-method-label"></span><h3>Make Workspace Function<a class="headerlink" href="#make-workspace-function" title="Link to this heading">#</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">FFT</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">FFT</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="p">)</span></code> is a helper function for creating workspace required for block <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">execute</span><span class="p">(...)</span></code> method
when <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>. <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span></code> is type of FFT descriptor. If no stream
argument is passed, the default 0 stream is used for execution. If after calling the function <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">error</span></code> is not <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaSuccess</span></code> the
workspace was not created correctly and is invalid.</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="p">)</span></code> is a helper function for creating workspace which will throw an exception, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span></code>
initialized with a string describing returned <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cudaError_t</span></code> code, if allocation of workspace failed. This is the only difference when compared with
<code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="p">)</span></code> helper function.</p>
<ul class="simple">
<li><p>If <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> trait is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">false</span></code>, user doesn’t have to create workspace.</p></li>
<li><p>Workspace can be created for FFT with <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">requires_workspace</span></code> equal to false: such workspace is an empty workspace with no global memory allocation.</p></li>
<li><p>Workspace object is valid only for FFT it was created for.</p></li>
<li><p>Workspace object can allocate global memory, however never more than <a class="reference internal" href="traits.html#workspacesize-block-trait-label"><span class="std std-ref">FFT::workspace_size</span></a>,
and it’s responsible for freeing it.</p></li>
<li><p>Workspace can’t be used concurrently since all copies share the same underlying global memory allocation. Using workspace concurrently will result in memory races.</p></li>
<li><p>Allocated global memory is freed upon destruction of the last copy of created workspace object.</p></li>
<li><p>Workspace object can be implicitly cast to <a class="reference internal" href="traits.html#workspacetype-block-trait-label"><span class="std std-ref">FFT::workspace_type</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Workspace is not required for FFTs of following sizes:</p>
<ul class="simple">
<li><p>Powers of 2 up to 32768.</p></li>
<li><p>Powers of 3 up to 19683.</p></li>
<li><p>Powers of 5 up to 15625.</p></li>
<li><p>Powers of 6 up to 7776.</p></li>
<li><p>Powers of 7 up to 16807.</p></li>
<li><p>Powers of 10 up to 10000.</p></li>
<li><p>Powers of 11 up to 1331.</p></li>
<li><p>Powers of 12 up to 1728.</p></li>
<li><p>Powers of 13 up to 2187.</p></li>
<li><p>Powers of 14 up to 2744.</p></li>
<li><p>Powers of 15 up to 3375.</p></li>
<li><p>Powers of 17 up to 4913.</p></li>
<li><p>Powers of 18 up to 5832.</p></li>
<li><p>Powers of 19 up to 6859.</p></li>
<li><p>Powers of 20 up to 8000.</p></li>
<li><p>Powers of 21 up to 9261.</p></li>
<li><p>Powers of 22 up to 10649.</p></li>
<li><p>Powers of 23 up to 12167.</p></li>
<li><p>Powers of 24 up to 13824.</p></li>
<li><p>Powers of 26 up to 17576.</p></li>
<li><p>Powers of 29 up to 21952.</p></li>
<li><p>Powers of 30 up to 27000.</p></li>
<li><p>Powers of 32 up to 29781.</p></li>
<li><p>Factors of 4 lower than 512.</p></li>
</ul>
<dl class="simple">
<dt>In the future versions of cuFFTDx:</dt><dd><ul class="simple">
<li><p>Workspace requirement may be removed for other configurations.</p></li>
<li><p>FFT configurations that do not require workspace will continue to do so.</p></li>
</ul>
</dd>
</dl>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><a class="reference internal" href="traits.html#workspacetype-block-trait-label"><span class="std std-ref">FFT::workspace_type</span></a> object doesn’t track lifetime of underlying memory, and
is only valid within a lifetime of workspace object it was casted from.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Type returned by <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cudaError_t</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="p">)</span></code> can be different for different FFT descriptions,
and is not the same as <a class="reference internal" href="traits.html#workspacetype-block-trait-label"><span class="std std-ref">FFT::workspace_type</span></a>. User should use <code class="code highlight cpp docutils literal highlight-cpp"><span class="k">auto</span></code> when
creating a workspace object. Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">FFT</span><span class="o">&gt;</span>
<span class="n">__launch_bounds__</span><span class="p">(</span><span class="n">FFT</span><span class="o">::</span><span class="n">max_threads_per_block</span><span class="p">)</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">block_fft_kernel</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">value_type</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">workspace_type</span><span class="w"> </span><span class="n">workspace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="c1">// Execute FFT</span>
<span class="w">    </span><span class="n">FFT</span><span class="p">().</span><span class="n">execute</span><span class="p">(</span><span class="n">thread_data</span><span class="p">,</span><span class="w"> </span><span class="n">shared_mem</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Create workspace</span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">workspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cufftdx</span><span class="o">::</span><span class="n">make_workspace</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// Run kernel with FFT</span>
<span class="n">block_fft_kernel</span><span class="o">&lt;</span><span class="n">FFT</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">block_dim</span><span class="p">,</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">shared_memory_size</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">workspace</span><span class="p">);</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="value-formats-and-data-layouts">
<span id="execution-methods-formats-layouts-label"></span><h2>Value Formats and Data Layouts<a class="headerlink" href="#value-formats-and-data-layouts" title="Link to this heading">#</a></h2>
<p>To perform the FFT correctly data needs to be passed to the library in a specific format described
in section <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a> and partitioned among threads as detailed in
section <a class="reference internal" href="#execution-methods-data-layout-label"><span class="std std-ref">Data Layouts</span></a>. The user is responsible for getting these
two factors right, but the library provides idioms, traits and examples which should make API use
accessible and intuitive.</p>
<section id="value-formats">
<span id="execution-methods-value-format-label"></span><h3>Value Formats<a class="headerlink" href="#value-formats" title="Link to this heading">#</a></h3>
<p>For complex numbers of single and double precision, the first value in a complex number is the real part and the second is
the imaginary part.</p>
<p>The input value format for complex-to-complex and complex-to-real FFTs is the aforementioned complex type, but for real-to-complex FFT this property is dependent on the use
of <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a> and specifically its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span></code> enum value. By default the real-to-complex execution takes real values as arguments,
but if the execution mode is set to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> the library performs an optimized execution which treats real input as complex input of half the size.
In this case the value format is complex (identical to that of complex-to-complex or complex-to-real) containing two real values.</p>
<p>Similarly, the output value format for complex-to-complex and real-to-complex FFTs is the complex type, but for complex-to-real FFT this property is dependent on the use
of <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a> and specifically its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span></code> enum value. By default the complex-to-real execution outputs real values as results,
but if the execution mode is set to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> the library performs an optimized execution which treats real output as complex output of half the size.
In this case the value format is complex (identical to that of complex-to-complex or complex-to-real) and otherwise it’s made of real values.</p>
<section id="half-precision-implicit-batching">
<span id="execution-methods-half-implicit-batching-label"></span><h4>Half Precision Implicit Batching<a class="headerlink" href="#half-precision-implicit-batching" title="Link to this heading">#</a></h4>
<p>Processing of half (fp16) precision FFTs in cuFFTDx is implicitly batched, that is, a single computation processes two FFT
batches. cuFFTDx expects that a complex number of half precision has 2 real parts and 2 imaginary parts in that order
(i.e real<sub>0</sub>, real<sub>1</sub>, imaginary<sub>0</sub>, imaginary<sub>1</sub>). Real values of half precision (for R2C and C2R FFTs)
follow the same logic and each should contain two real values. See also <a class="reference internal" href="traits.html#implicit-type-batching-block-trait-label"><span class="std std-ref">FFT::implicit_type_batching</span></a>
trait.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{complex half precision value:}\;\; &amp; (real_0, real_1, imaginary_0, imaginary_1) \\
\text{real half precision value:}\;\;    &amp; (real_0, real_1) \\\end{split}\]</div>
</section>
</section>
<section id="data-layouts">
<span id="execution-methods-data-layout-label"></span><h3>Data Layouts<a class="headerlink" href="#data-layouts" title="Link to this heading">#</a></h3>
<p>Input and output data layouts of an FFT depend strictly on its configuration and the selected transform type. A data layout
describes the size and the pattern of input or output data for the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">execute</span></code> methods, no matter if input/output are partitioned
between threads into thread local arrays or stored contiguously in shared memory.</p>
<p>As the section <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a> put forth, the input / output formats are either real or complex. Another
important execution attribute is the sequence length.
In complex-to-complex transforms this property is equal to transform size, but for real-to-complex and complex-to-real
the library offers a few options to choose from.
This choice can be made by means of the <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a> operator.</p>
<p>The sections below provide detailed descriptions of the input and output data layouts for both
<a class="reference internal" href="#thread-execute-method-label"><span class="std std-ref">thread</span></a> and <a class="reference internal" href="#block-execute-method-label"><span class="std std-ref">block</span></a> execution modes .</p>
<section id="complex-to-complex">
<span id="c2c-data-layouts-label"></span><h4>Complex-to-complex<a class="headerlink" href="#complex-to-complex" title="Link to this heading">#</a></h4>
<p>In the case of complex-to-complex transforms both the input and output data must be a complex array in a corresponding precision.
Both input and output arrays are always of the same length, equal to the size of the FFT.</p>
<section id="input-output-in-registers-for-thread-execution">
<h5>Input/Output in Registers for Thread Execution<a class="headerlink" href="#input-output-in-registers-for-thread-execution" title="Link to this heading">#</a></h5>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> in the natural order.
Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.</p>
</section>
<section id="input-output-in-registers-for-block-execution">
<h5>Input/Output in Registers for Block Execution<a class="headerlink" href="#input-output-in-registers-for-block-execution" title="Link to this heading">#</a></h5>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span></code>-th thread (indexing from 0) participating in the FFT should include the following elements of FFT in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>
values: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span></code> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">i</span></code> is an index in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>.
Results are later stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.
Please note that in certain cases, especially if <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>, the
values are not partitioned equally between threads.</p>
<p>See also <a class="reference internal" href="traits.html#stride-block-trait-label"><span class="std std-ref">FFT::stride</span></a>.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<p>0th thread of 8-point FFT with <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span></code> equal to 2 should have values 0, 2, 4, and 6 in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>.</p>
<p>Elements are not always perfectly divisible among threads:
0th thread of a 7-point FFT with <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span></code> equal to 2 should have values 0, 2, 4, and 6 in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>, while the 1st thread should have values 1, 3 and 5.</p>
</div>
</section>
<section id="input-output-in-shared-memory-for-block-execution">
<h5>Input/Output in Shared Memory for Block Execution<a class="headerlink" href="#input-output-in-shared-memory-for-block-execution" title="Link to this heading">#</a></h5>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> in the natural order.
Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> following the same rule.</p>
</section>
</section>
<section id="real-to-complex-and-complex-to-real">
<h4>Real-to-complex and complex-to-real<a class="headerlink" href="#real-to-complex-and-complex-to-real" title="Link to this heading">#</a></h4>
<p>For real-to-complex (R2C) and complex-to-real (C2R) FFT input and output data layouts depend on the <a class="reference internal" href="operators.html#real-fft-options-operator-label"><span class="std std-ref">RealFFTOptions Operator</span></a>.
By default <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">RealFFTOptions</span></code> is set to <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> and <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code>.</p>
<ul class="simple">
<li><p>Complex layouts: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> (default), <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code>, <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code>.</p></li>
<li><p>Real modes: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> (default), <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code>.</p></li>
</ul>
<section id="complex-element-layouts">
<span id="complex-data-layouts-label"></span><h5>Complex Element Layouts<a class="headerlink" href="#complex-element-layouts" title="Link to this heading">#</a></h5>
<p>Complex element layout is defined for the complex-to-real input and real-to-complex output.
It depends on the passed <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span></code> value of the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">RealFFTOptions</span></code> operator.</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> for even length ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), … , (r <sub>N/2</sub>, i <sub>N/2</sub> = 0)), only non-redundant <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span></code> elements, with first and last elements containing only real parts.</p>
<ul>
<li><p>imag<sub>0</sub> and imag<sub>N/2</sub> are both assumed to 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> for odd length ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), … , (r <sub>⌊N/2⌋</sub>, i <sub>⌊N/2⌋</sub>)), only non-redundant <code class="code highlight cpp docutils literal highlight-cpp"><span class="err">⌊</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="err">⌋</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span></code> elements, with first element containing only the real part.</p>
<ul>
<li><p>imag<sub>0</sub> is assumed to be 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code> ((r<sub>0</sub>, i<sub>0</sub>), (r<sub>1</sub>, i<sub>1</sub>), … , (r <sub>N/2 - 1</sub>, i <sub>N/2 - 1</sub>)), packs the last real element into the imaginary component of the first element.</p>
<ul>
<li><p>Packing means that the first element x<sub>0</sub> contains (real<sub>0</sub>, real<sub>⌊N/2⌋</sub>).</p></li>
<li><p>Allowed only for even sizes, e.g. for 16-point FFT the length is 8, for 15-point it is unavailable.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code> for even lengths ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), … , (r<sub>N/2</sub>, i<sub>N/2</sub> = 0), … , (r<sub>N - 1</sub>, i<sub>N - 1</sub>)), all elements, including redundant ones, since the output is hermitian.</p>
<ul>
<li><p>For example, for 16-point FFT the length is 16</p></li>
<li><p>imag<sub>0</sub> and imag<sub>N/2</sub> are both assumed to be 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code> for odd lengths ((r<sub>0</sub>, i<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub> ), … , (r<sub>N - 1</sub>, i<sub>N - 1</sub>)), all elements, including redundant ones, since the output is hermitian.</p>
<ul>
<li><p>For example, for 15-point FFT the length is 15</p></li>
<li><p>imag<sub>0</sub> is assumed to be 0 due to mathematical properties of complex-to-real FFT input signal.</p></li>
</ul>
</li>
</ul>
<section id="complex-input-output-in-registers-for-thread-execution">
<h6>Complex Input/Output in Registers for Thread Execution<a class="headerlink" href="#complex-input-output-in-registers-for-thread-execution" title="Link to this heading">#</a></h6>
<p>Follows the same rules as described in <a class="reference internal" href="#complex-data-layouts-block-smem-label"><span class="std std-ref">Complex Input/Output In Shared Memory for Block Execution</span></a>, but
the input/output data is stored in a thread local array.</p>
</section>
<section id="complex-input-output-in-registers-for-block-execution">
<h6>Complex Input/Output in Registers for Block Execution<a class="headerlink" href="#complex-input-output-in-registers-for-block-execution" title="Link to this heading">#</a></h6>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span></code>-th thread (indexing from 0) participating in the FFT should include the following elements of FFT in its <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>
values: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span></code> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">i</span></code> is an index in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>. Results are later stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.
Please note that in certain cases, especially if <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>, the
values are not partitioned equally between threads.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 16-point FP32/FP64 C2R FFT with <a class="reference internal" href="operators.html#ept-operator-label"><span class="std std-ref">ElementsPerThread</span></a> set or defaulted to 4
(implying 4 threads, and <a class="reference internal" href="traits.html#stride-block-trait-label"><span class="std std-ref">FFT::stride</span></a> equal to 4):</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code>: the input layout (first row) and required partitioning of the data (entire table) into thread local arrays is presented below:</p>
<blockquote>
<div><div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, i<sub>0</sub> = 0)</p></th>
<th class="head"><p>(r<sub>1</sub>, i<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, i<sub>2</sub>)</p></th>
<th class="head"><p>(r<sub>3</sub>, i<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, i<sub>4</sub>)</p></th>
<th class="head"><p>(r<sub>5</sub>, i<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, i<sub>6</sub>)</p></th>
<th class="head"><p>(r<sub>7</sub>, i<sub>7</sub>),</p></th>
<th class="head"><p>(r<sub>8</sub>, i<sub>8</sub> = 0)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code>: the input layout (first row) and required partitioning of the data (entire table) into a thread array is presented below:</p>
<blockquote>
<div><div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, r<sub>8</sub>)</p></th>
<th class="head"><p>(r<sub>1</sub>, i<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, i<sub>2</sub>)</p></th>
<th class="head"><p>(r<sub>3</sub>, i<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, i<sub>4</sub>)</p></th>
<th class="head"><p>(r<sub>5</sub>, i<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, i<sub>6</sub>)</p></th>
<th class="head"><p>(r<sub>7</sub>, i<sub>7</sub>),</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code>: the input layout (first row) and required partitioning of the data (entire table) into thread local arrays is presented below:</p>
<blockquote>
<div><div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, i<sub>0</sub> = 0)</p></th>
<th class="head"><p>(r<sub>1</sub>, i<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, i<sub>2</sub>)</p></th>
<th class="head"><p>(r<sub>3</sub>, i<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, i<sub>4</sub>)</p></th>
<th class="head"><p>(r<sub>5</sub>, i<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, i<sub>6</sub>)</p></th>
<th class="head"><p>(r<sub>7</sub>, i<sub>7</sub>),</p></th>
<th class="head"><p>(r<sub>8</sub>, i<sub>8</sub> = 0)</p></th>
<th class="head"><p>(r<sub>9</sub>, i<sub>9</sub>)</p></th>
<th class="head"><p>(r<sub>10</sub>, i<sub>10</sub>)</p></th>
<th class="head"><p>(r<sub>11</sub>, i<sub>11</sub>)</p></th>
<th class="head"><p>(r<sub>12</sub>, i<sub>12</sub>)</p></th>
<th class="head"><p>(r<sub>13</sub>, i<sub>13</sub>)</p></th>
<th class="head"><p>(r<sub>14</sub>, i<sub>14</sub>)</p></th>
<th class="head"><p>(r<sub>15</sub>, i<sub>15</sub>),</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<p>The layouts and the required partitioning look similarly for R2C output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</section>
<section id="complex-input-output-in-shared-memory-for-block-execution">
<span id="complex-data-layouts-block-smem-label"></span><h6>Complex Input/Output in Shared Memory for Block Execution<a class="headerlink" href="#complex-input-output-in-shared-memory-for-block-execution" title="Link to this heading">#</a></h6>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> in the natural order.
Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> following the same rule.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 8-point FP32/FP64 C2R FFT:</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">natural</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, imag<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), (r<sub>2</sub>, i<sub>2</sub>), (r<sub>3</sub>, i<sub>3</sub>),(r<sub>4</sub>, i<sub>4</sub> = 0)].</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">packed</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, real<sub>4</sub>), (r<sub>1</sub>, i<sub>1</sub>), (r<sub>2</sub>, i<sub>2</sub>), (r<sub>3</sub>, i<sub>3</sub>)].</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">complex_layout</span><span class="o">::</span><span class="n">full</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, imag<sub>0</sub> = 0), (r<sub>1</sub>, i<sub>1</sub>), (r<sub>2</sub>, i<sub>2</sub>), (r<sub>3</sub>, i<sub>3</sub>),(r<sub>4</sub>, i<sub>4</sub> = 0), (r<sub>5</sub>, i<sub>5</sub>), (r<sub>6</sub>, i<sub>6</sub>), (r<sub>7</sub>, i<sub>7</sub>)].</p></li>
</ul>
<p>The layouts look similarly for R2C output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</section>
</section>
<section id="real-element-layouts">
<span id="real-data-layouts-label"></span><h5>Real Element Layouts<a class="headerlink" href="#real-element-layouts" title="Link to this heading">#</a></h5>
<p>Real element layout is defined for the complex-to-real output and real-to-complex input.
It depends on <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span></code> parameter of the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">RealFFTOptions</span></code> operator:</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> (x<sub>0</sub>, x<sub>1</sub>, … , x<sub>N - 1</sub>), real element array of length equal to the transformation size.</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> (x<sub>0</sub>, x<sub>1</sub>, … , x <sub>N/2 - 1</sub>), complex element array of length half that of the transformation size.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The physical layout of the elements in shared memory is the same as in the <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> case, but the logical one changes: instead of being an array of real values, it is an array of complex values.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> execution is dependent on certain FFT characteristics, and currently it is available in block execution only
for sizes equal to 2<sup>N</sup> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">N</span></code> is any exponent which still makes the transform fit into available size range. For thread
execution this optimization supports all sizes equal to 2 * N, where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">N</span></code> is any multiplier which makes the transform fit into available
size range. Using <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">folded</span></code> execution doubles the size limit available otherwise. Consult <a class="reference internal" href="../requirements_func.html#functionality-label"><span class="std std-ref">Supported Functionality</span></a> for further details.</p>
</div>
<section id="real-input-output-in-registers-for-thread-execution">
<h6>Real Input/Output in Registers for Thread Execution<a class="headerlink" href="#real-input-output-in-registers-for-thread-execution" title="Link to this heading">#</a></h6>
<p>Follows the same rules as described in <a class="reference internal" href="#real-data-layouts-block-smem-label"><span class="std std-ref">Reak Input/Output In Shared Memory for Block Execution</span></a>, but
the input/output data is stored in a thread local array.</p>
</section>
<section id="real-input-output-in-registers-for-block-execution">
<h6>Real Input/Output in Registers for Block Execution<a class="headerlink" href="#real-input-output-in-registers-for-block-execution" title="Link to this heading">#</a></h6>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span></code>-th thread (indexing from 0) participating in the FFT should include the following values of type <a class="reference internal" href="traits.html#input-type-block-trait-label"><span class="std std-ref">Input Type Trait</span></a>
: <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span></code> where <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">i</span></code> is an index in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code>.
Results are later stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">input</span></code> following the same rule.
Please note that in certain cases, especially if <a class="reference internal" href="traits.html#requiresworkspace-block-trait-label"><span class="std std-ref">FFT::requires_workspace</span></a> is <code class="code highlight cpp docutils literal highlight-cpp"><span class="nb">true</span></code>, the
values are not partitioned equally between threads.
It is also important to remember that the count of values of this type per thread will be <a class="reference internal" href="traits.html#input-ept-block-trait-label"><span class="std std-ref">Input EPT Trait</span></a> and not <a class="reference internal" href="traits.html#ept-block-trait-label"><span class="std std-ref">Elements Per Thread Trait</span></a></p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 16-point FP32/FP64 R2C FFT with <a class="reference internal" href="operators.html#ept-operator-label"><span class="std std-ref">ElementsPerThread</span></a> set or defaulted to 4:</p>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> input layout looks like this: [real<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>, r<sub>3</sub>, r<sub>4</sub>, r<sub>5</sub>, r<sub>6</sub>, r<sub>7</sub>].
The required partitioning of the data into thread local arrays is presented below:</p>
<blockquote>
<div><div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>r<sub>0</sub></p></th>
<th class="head"><p>r<sub>1</sub></p></th>
<th class="head"><p>r<sub>2</sub></p></th>
<th class="head"><p>r<sub>3</sub></p></th>
<th class="head"><p>r<sub>4</sub></p></th>
<th class="head"><p>r<sub>5</sub></p></th>
<th class="head"><p>r<sub>6</sub></p></th>
<th class="head"><p>r<sub>7</sub></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> input layout looks like this: [(real<sub>0</sub>, r<sub>1</sub>), (r<sub>2</sub>, r<sub>3</sub>), (r<sub>4</sub>, r<sub>5</sub>), (r<sub>6</sub>, r<sub>7</sub>)].
The required partitioning of the data into thread local arrays is presented below:</p>
<blockquote>
<div><div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>thread / element</p></th>
<th class="head"><p>(r<sub>0</sub>, r<sub>1</sub>)</p></th>
<th class="head"><p>(r<sub>2</sub>, r<sub>3</sub>)</p></th>
<th class="head"><p>(r<sub>4</sub>, r<sub>5</sub>)</p></th>
<th class="head"><p>(r<sub>6</sub>, r<sub>7</sub>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td></td>
<td></td>
<td></td>
<td><p class="centered">
<strong>X</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
<p>The layouts and the required partitioning look similarly for C2R output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</section>
<section id="real-input-output-in-shared-memory-for-block-execution">
<span id="real-data-layouts-block-smem-label"></span><h6>Real Input/Output in Shared Memory for Block Execution<a class="headerlink" href="#real-input-output-in-shared-memory-for-block-execution" title="Link to this heading">#</a></h6>
<p>The input values of the FFT should be stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> in natural order. Results are stored in <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code>
following the same rule.</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<blockquote>
<div><p>For 8-point FP32/FP64 R2C FFT:</p>
<ul class="simple">
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">normal</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [real<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub>, r<sub>3</sub>, r<sub>4</sub>, r<sub>5</sub>, r<sub>6</sub>, r<sub>7</sub>]</p></li>
<li><p><code class="code highlight cpp docutils literal highlight-cpp"><span class="n">real_mode</span><span class="o">::</span><span class="n">folded</span></code> input layout for <code class="code highlight cpp docutils literal highlight-cpp"><span class="n">shared_memory_input</span></code> looks like this: [(real<sub>0</sub>, r<sub>1</sub>), (r<sub>2</sub>, r<sub>3</sub>), (r<sub>4</sub>, r<sub>5</sub>), (r<sub>6</sub>, r<sub>7</sub>)]</p></li>
</ul>
<p>The layouts look similarly for C2R output.</p>
<p>Half-precision FFTs follow the same rules but <a class="reference internal" href="#execution-methods-half-implicit-batching-label"><span class="std std-ref">the implicit batching</span></a> has be taken into account.</p>
</div></blockquote>
</div>
</section>
</section>
</section>
<section id="loading-and-storing-data">
<h4>Loading and Storing Data<a class="headerlink" href="#loading-and-storing-data" title="Link to this heading">#</a></h4>
<p>To deal with the complexity of changing input and output lengths depending on configuration, the library provides
various traits allowing for easy memory operations. <a class="reference internal" href="traits.html#input-length-block-trait-label"><span class="std std-ref">Input Length Trait</span></a> and
<a class="reference internal" href="traits.html#output-length-block-trait-label"><span class="std std-ref">Output Length Trait</span></a> describe lengths of respectively input and output arrays.
This covers real-to-complex (R2C) and complex-to-real (C2R) cases described above.
<a class="reference internal" href="traits.html#input-ept-block-trait-label"><span class="std std-ref">Input EPT Trait</span></a> describes the count of elements to be loaded by each thread,
assuming that each element is of type <a class="reference internal" href="traits.html#input-type-block-trait-label"><span class="std std-ref">Input Type Trait</span></a>.
Respectively <a class="reference internal" href="traits.html#output-ept-block-trait-label"><span class="std std-ref">Output EPT Trait</span></a> and <a class="reference internal" href="traits.html#output-type-block-trait-label"><span class="std std-ref">Output Type Trait</span></a> describe the same properties for storing output.</p>
<p>The detailed idiomatic IO is shown in <a class="reference internal" href="../examples.html#examples-label"><span class="std std-ref">examples</span></a>, but the general approach for loading data from global memory is as follows:</p>
<div class="hint admonition">
<p class="admonition-title">Example</p>
<p><strong>Block FFT with Data in Registers</strong></p>
<p>The following example shows block trait-based universal loading scheme for cuFFTDx register API execution mode. Here
a thread group performs an FFT cooperatively, so the data needs to be spread among all participants. The following
code snippets already account for this partitioning, but also different value formats (as described in
<a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a>) and data layouts (as described in <a class="reference internal" href="#real-data-layouts-label"><span class="std std-ref">Real Element Layouts</span></a>
and <a class="reference internal" href="#complex-data-layouts-label"><span class="std std-ref">Complex Element Layouts</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Which FFT in this block is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">local_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="c1">// Which FFT in this grid is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">local_fft_id</span><span class="p">;</span>
<span class="c1">// Memory offset for accessing the first element of the global_fft</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>

<span class="c1">// Cast registers to type required as input to FFT execution</span>
<span class="k">using</span><span class="w"> </span><span class="n">input_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">input_type</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">thread_fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">thread_data</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_ept</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">thread_fft_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fft_data</span><span class="p">[</span><span class="n">global_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">];</span>
<span class="w">      </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">stride</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p><strong>Block FFT with Data in Shared Memory</strong></p>
<p>The following example shows block trait-based universal loading scheme for cuFFTDx shared memory API execution mode. Here
entire CUDA block performs <a class="reference internal" href="traits.html#fftsperblock-block-trait-label"><span class="std std-ref">FFTs Per Block Trait</span></a> FFTs cooperatively, so the data in shared memory needs to contain
all necessary batches. To access memory in coalesced manner the loading of all batches is performed by the entire threadblock.
The following code snippet accounts for different value formats (as described in <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a>)
and data layouts (as described in <a class="reference internal" href="#real-data-layouts-label"><span class="std std-ref">Real Element Layouts</span></a> and <a class="reference internal" href="#complex-data-layouts-label"><span class="std std-ref">Complex Element Layouts</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The index of first FFT being performed by threads of this block</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">block_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="p">;</span>
<span class="c1">// Offset in memory to the first element accessed by threads in this block</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">block_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_fft_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>
<span class="c1">// Combined length of all FFTs performed by threads of this block</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">block_input_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">ffts_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>

<span class="c1">// Cast registers to type required as input to FFT execution</span>
<span class="k">using</span><span class="w"> </span><span class="n">input_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">input_type</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">shared_fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">shared_memory</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="c1">// The entire block loads all required batches in a coalesced manner,</span>
<span class="c1">// threads will load elements from different batches than they will later</span>
<span class="c1">// execute on, and this is on purpose.</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">index</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_ept</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">block_input_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">shared_fft_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fft_data</span><span class="p">[</span><span class="n">block_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following example shows thread trait-based universal loading scheme for cuFFTDx execution. Here a single thread
performs entire FFT, so there is no need to partition data, it will perform a load of entire sequence. This already
accounts for different value_formats (as described in <a class="reference internal" href="#execution-methods-value-format-label"><span class="std std-ref">Value Formats</span></a>) and data layouts
(as described in <a class="reference internal" href="#real-data-layouts-label"><span class="std std-ref">Real Element Layouts</span></a> and <a class="reference internal" href="#complex-data-layouts-label"><span class="std std-ref">Complex Element Layouts</span></a>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This example assumes a 2-dimensional block and 1-dimensional grid</span>

<span class="c1">// Which FFT in block is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">local_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="c1">// Which FFT in grid is this thread performing</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">local_fft_id</span><span class="p">;</span>
<span class="c1">// Memory offset for accessing first element of this FFT</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">global_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_fft_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span>

<span class="c1">// Cast registers to type required as input to FFT execution</span>
<span class="k">using</span><span class="w"> </span><span class="n">input_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">FFT</span><span class="o">::</span><span class="n">input_type</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">thread_fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">thread_data</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">fft_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">input_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FFT</span><span class="o">::</span><span class="n">input_length</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">thread_fft_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fft_data</span><span class="p">[</span><span class="n">global_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="traits.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Traits</p>
      </div>
    </a>
    <a class="right-next"
       href="../python_bindings.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">cuFFTDx Python Bindings</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            


              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#thread-execute-method">Thread Execute Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#block-execute-method">Block Execute Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shared-memory-usage">Shared Memory Usage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#make-workspace-function">Make Workspace Function</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#value-formats-and-data-layouts">Value Formats and Data Layouts</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#value-formats">Value Formats</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#half-precision-implicit-batching">Half Precision Implicit Batching</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-layouts">Data Layouts</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-to-complex">Complex-to-complex</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#input-output-in-registers-for-thread-execution">Input/Output in Registers for Thread Execution</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#input-output-in-registers-for-block-execution">Input/Output in Registers for Block Execution</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#input-output-in-shared-memory-for-block-execution">Input/Output in Shared Memory for Block Execution</a></li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#real-to-complex-and-complex-to-real">Real-to-complex and complex-to-real</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-element-layouts">Complex Element Layouts</a><ul class="nav section-nav flex-column">
<li class="toc-h6 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-input-output-in-registers-for-thread-execution">Complex Input/Output in Registers for Thread Execution</a></li>
<li class="toc-h6 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-input-output-in-registers-for-block-execution">Complex Input/Output in Registers for Block Execution</a></li>
<li class="toc-h6 nav-item toc-entry"><a class="reference internal nav-link" href="#complex-input-output-in-shared-memory-for-block-execution">Complex Input/Output in Shared Memory for Block Execution</a></li>
</ul>
</li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#real-element-layouts">Real Element Layouts</a><ul class="nav section-nav flex-column">
<li class="toc-h6 nav-item toc-entry"><a class="reference internal nav-link" href="#real-input-output-in-registers-for-thread-execution">Real Input/Output in Registers for Thread Execution</a></li>
<li class="toc-h6 nav-item toc-entry"><a class="reference internal nav-link" href="#real-input-output-in-registers-for-block-execution">Real Input/Output in Registers for Block Execution</a></li>
<li class="toc-h6 nav-item toc-entry"><a class="reference internal nav-link" href="#real-input-output-in-shared-memory-for-block-execution">Real Input/Output in Shared Memory for Block Execution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#loading-and-storing-data">Loading and Storing Data</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            

          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
<a class="footer-brand logo" href="https://www.nvidia.com">
  <img src="../_static/nvidia-logo-horiz-rgb-1c-blk-for-screen.svg" class="logo__image only-light" alt="NVIDIA"/>
  <img src="../_static/nvidia-logo-horiz-rgb-1c-wht-for-screen.svg" class="logo__image only-dark" alt="NVIDIA"/>
</a></div>
      
        <div class="footer-item">

<div class="footer-links">
  
  
  <a class="external" href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/">Privacy Policy</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/">Manage My Privacy</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/preferences/start/">Do Not Sell or Share My Data</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/">Terms of Service</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/about-nvidia/accessibility/">Accessibility</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/about-nvidia/company-policies/">Corporate Policies</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/product-security/">Product Security</a>
   | 
  
  
  
  <a class="external" href="https://www.nvidia.com/en-us/contact/">Contact</a>
  
  
  
</div>
</div>
      
        <div class="footer-item">




  <p class="copyright">
    
      Copyright © 2022-2025, NVIDIA Corporation &amp; Affiliates. All rights reserved.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>